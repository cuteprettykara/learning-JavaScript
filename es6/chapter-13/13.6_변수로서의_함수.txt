숫자나 문자열, 배열은 변수라고 생각해도 별 거부감이 없습니다. 
[변수는 데이터]라는 생각, 배열이나 객체는 [데이터의 모임]이라는 생각은 익숙하니까요.

하지만 변수를 이렇게 이해하면 함수의 잠재력을 완전히 깨닫기 어려울 수 있습니다.
함수도 다른 변수와 마찬가지로 이리저리 전달할 수 있다는 사실을 떠올리기 어렵기 때문입니다.

함수는 능동적인 것이므로, 우리가 보통 수동적이라고 생각하는 데이터와 연결이 잘 되지 않을 수 있습니다.
* 물론 함수는 호출되었을 때는 능동적입니다.
* 하지만 호출하기 전에는 다른 변수와 마찬가지로 수동적입니다.

슈퍼마켓에 과일을 사러 간다고 합시다.
이때 [과일은 데이터]라고 생각할 수 있습니다.
그런데 사과와 바나나를 넣어 스무디를 만들고 싶어져서, 블렌더도 하나 사기로 했습니다.
[블렌더는 함수]라고 생각할 수 있습니다. 과일을 넣으면 스무디를 만드는 능동적인 것이니까요.

하지만 블렌더는 전원을 연결하고 과일을 넣기 전에는, 과일과 마찬가지로 하나의 물건일 뿐입니다.
카트에서 꺼내 계산대에 올리고, 결제하고, 쇼핑백에 넣어 집으로 가져옵니다. 과일과 다를 게 하나도 없습니다.
블렌더가 과일과 달라질 때는 전원을 연결하고 과일을 넣었을 때 뿐입니다.

자, 변수가 있을 수 있는 곳에는 함수도 있을 수 있습니다. 그럼 이 사실은 무엇을 의미할까요?
간추려 보면, 다음과 같은 일을 할 수도 있다는 뜻입니다.

* 함수를 가리키는 변수를 만들어 별명을 정할 수 있습니다.
* 배열에 함수를 넣을 수 있습니다. 물론 다른 타입의 데이터와 섞일 수 있습니다.
* 함수를 객체의 프로퍼티로 사용할 수 있습니다(9장).
* 함수를 함수에 전달할 수 있습니다.
* 함수가 함수를 반환할 수 있습니다.
* 함수를 매개변수로 받는 함수를 반환하는 것도 물론 가능합니다.

가장 쉬운 함수에 별명을 붙이는 것부터 생각해 봅시다.
짧은 코드 안에서 여러 번 호출해야 하는 함수가 있습니다.
그런데 이 함수의 이름이 너무 길어서 타이핑하기가 번거로울 뿐 아니라, 코드를 읽기도 무척 어려울 것 같습니다.
함수도 데이터이므로 짧은 이름의 변수에 저장할 수 있습니다.

...

