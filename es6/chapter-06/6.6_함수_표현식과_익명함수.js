// 지금까지는 함수 선언만 봤습니다.
// 함수를 선언하면 함수에 바디와 식별자가 모두 주어집니다.
// 익명함수에서는 함수에 식별자가 주어지지 않습니다.

// 식별자가 없다면, 도대체 함수를 어떻게 호출해야 할까요?
// 답은 함수 표현식(function expression)에 있습니다.
// 함수 표현식은 함수를 선언하는 한 가지 방법입니다.

// 함수 표현식은
// 1. 식별자에 할당할 수도 있고,
// 2. 즉시 호출(IIFE)할 수도 있습니다.

// 함수 표현식을 쓰고 그 결과를 변수에 할당하는 예제를 봅시다.
// 이 예제는 결과적으로 함수 선언과 동일합니다.
// const f = function() {
//     // ...
// }

// 결과는 여태까지 했던 대로 함수를 선언한 것과 마찬가지입니다.
// 식별자 f가 이 함수를 가리킵니다.

// 차이점은 먼저 함수 표현식으로 익명 함수를 만들고, 그 함수를 변수에 할당했다는 겁니다.

// 앞에서 함수 표현식에서는 함수 이름을 생략할 수 있다고 했습니다.
// 그러면 함수에 이름을 정하고 다시 변수에 할당하면 어떻게 될까요?
// 그리고 그렇게 한다면 이유는 무엇일까요?
// const g = function f() {
//     console.log('f');
// }

// 이런 식으로 함수를 만들면 이름 g에 우선순위가 있습니다.
// 함수 바깥에서 함수에 접근할 때는 g를 써야 하며, 
// f로 접근하려 하면 변수가 정의되지 않았다는 에러가 생깁니다.
// g();    // 'f'
// f();    // ReferenceError: f is not defined


// 그렇다면 왜 이런 방법을 사용하는 걸까요?
// 함수 안에서 자신을 호출할 때(재귀) 이런 방식이 필요할 수 있습니다.
const g = function f(stop) {
    console.log('inside f');
    if (stop) {
        console.log('f stopped');
        return;
    }
    f(true);
};

g(false);

// 함수 안에서는 f를 써서 자기 자신을 참조하고,
// 함수 바깥에서는 g를 써서 함수를 호출합니다.

// [나중에 호출]할 생각으로 함수를 만든다면, 함수 선언을 사용하면 되고,
// 다른 곳에 [할당]하거나 다른 함수에 [넘길] 목적으로 함수를 만든다면, 함수 표현식을 사용하면 됩니다.