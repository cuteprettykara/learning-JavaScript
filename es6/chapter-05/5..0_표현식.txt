표현식(expression)은 [값]으로 [평가]될 수 있는 [문]입니다.
즉, 결과가 [값]인 [문]과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다.
이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다.

표현식이 아닌 문(statement)은 일종의 [지시]라고 생각할 수 있고,
표현식은 무언가를 [요청]하는 것이라고 생각할 수 있습니다.

상사가 "볼트A를 너트B에 끼우세요."                               => 지시 => 표현식이 아닌 문(statement)
상사가 "볼트A를 너트B에 끼우고, 내가 검사할 수 있도록 가져오세요."         => 표현식(expression)
     => 당신은 지시를 받았고, 그 결과를 [반환]해야 합니다.

[결과를] 명시적으로 [반환]하는 것은 [표현식]입니다.


표현식은 [값]이 됩니다.
그 결과를 [다른 표현식]에 [결합]해서 다른 값을 얻을 수 있습니다.
표현식이 아닌 문(statement)은 이런 식으로 결합할 수 없습니다.


표현식은 값이 되므로 [할당]에 쓸 수 있습니다.
    let x;
    x = 3 * 5;

두 번째 행을 잘 봅시다. 이 행에는 사실 표현식이 두 개 있습니다.
첫 번째 표현식은 3 *5 입니다. 곱셈 표현식이고, 결과는 15입니다.
그 다음은 값 15를 변수 x에 할당한 표현식입니다. 할당은 그 자체가 표현식입니다.

음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요?
x만 값 15를 할당 받는 것이 아니라, [전체 표현식의 결과]도 값 15입니다.
따라서 값이 되므로, [다른 변수에 다시 할당]할 수 있습니다.
다음 예제를 봅시다.

    let x, y;
    y = x = 3 * 5;

자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다.

    let x, y;
    y = x = 3 * 5;  // 원래 문
    y = x = 15;     // 곱셈 표현식을 평가
    y = 15;         // 첫 번째 할당을 평가했습니다. x는 이제 15이고, y는 아직 undefined 입니다.
    15;             // 두 번째 할당을 평가했습니다. y는 이제 15입니다.
                    // 전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고, 
                    // 어딘가에 할당하지도 않았으니 그냥 [버려집니다].

그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다.
즉, y = x를 먼저 실행해서 y에 undefined를 할당하고, 그 다음에 곱셈을 해서 y는 undefined로 남고,
x가 15가 될 수도 있지 않느냐는 말입니다.

자바스크립트가 [표현식을 평가하는 순서]를 [연산자 우선순위]라 부릅니다.
표현식은 대부분 [연산자(operator) 표현식] 입니다.


연산자 표현식이 [아닌] 표현식에는 

    1. 식별자 표현식(변수와 상수 이름),
    2. 리터럴 표현식 

두 가지가 있습니다.

변수와 상수, 리터럴은 그 자체가 표현식입니다.
값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다.